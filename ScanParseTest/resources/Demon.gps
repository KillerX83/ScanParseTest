MONE  EQU       -1
DISTR   MATRIX    ,4,4
        INITIAL   MX$DISTR(1,1),1
        INITIAL   MX$DISTR(1,2),2
        INITIAL   MX$DISTR(1,3),3
        INITIAL   MX$DISTR(1,4),4
        INITIAL   MX$DISTR(2,1),1
        INITIAL   MX$DISTR(2,2),2
        INITIAL   MX$DISTR(2,3),3
        INITIAL   MX$DISTR(2,4),4
        INITIAL   MX$DISTR(3,1),1
        INITIAL   MX$DISTR(3,2),2
        INITIAL   MX$DISTR(3,3),3
        INITIAL   MX$DISTR(3,4),4
        INITIAL   MX$DISTR(4,1),1
        INITIAL   MX$DISTR(4,2),2
        INITIAL   MX$DISTR(4,3),3
        INITIAL   MX$DISTR(4,4),4
IATR    FUNCTION  P$NODE,L4
1,1
2,2
3,3
4,4
TSERV   FUNCTION  P$NODE,L4
1,1
2,2
3,3
4,4
SERV1 EQU        1
SERV1 STORAGE    1
SERV2 EQU        2
SERV2 STORAGE    2
SERV3 EQU        3
SERV3 STORAGE    3
SERV4 EQU        4
SERV4 STORAGE    4
       RMULT      5
       GENERATE	  ,,,1,1
       ASSIGN	  ROW,4
CIKL1  ASSIGN	  SUM,0
       ASSIGN	  NCOL,4
CIKL2  ASSIGN	  COL,(4+1-P$NCOL)
       ASSIGN	  SUM+,MX$DISTR(P$ROW,P$COL)
       MSAVEVALUE DISTR,P$ROW,P$COL,P$SUM
       LOOP	  NCOL,CIKL2
       LOOP	  ROW,CIKL1	      
       TERMINATE	  
       GENERATE   ,,,1
       ASSIGN     NODE,MONE
       SPLIT      4,ENT1,NODE
       TERMINATE
ENT1   ASSIGN     TARR,FN$IATR
       TEST E     P$TARR,0,ENT2
       TERMINATE
ENT2   ADVANCE    (Exponential(1,0,P$TARR))
       SPLIT      1,ENT2
       QUEUE      NETW
ENT3   QUEUE      P$NODE
       ENTER      P$NODE
       DEPART     P$NODE
       ADVANCE    (Exponential(1,0,FN$TSERV))
       LEAVE      P$NODE
       SAVEVALUE  RAND,(RN1/1000)
       ASSIGN     NCOL,4
CIKL3  ASSIGN     COL,(4+1-P$NCOL)
       TEST LE    X$RAND,MX$DISTR(P$NODE,P$COL),ENDC
       ASSIGN     NODE,P$COL
       TRANSFER   ,ENT3
ENDC   LOOP	  NCOL,CIKL3
       DEPART     NETW
       TEST E     TG1,1,TERM1
       OPEN	  ("Demon.res"),,FCLOSE
       WRITE      (Round(SR1/1000,3)),,FCLOSE
       WRITE      (Round(QT1,3)),,FCLOSE
       WRITE      (Round(SR2/1000,3)),,FCLOSE
       WRITE      (Round(QT2,3)),,FCLOSE
       WRITE      (Round(SR3/1000,3)),,FCLOSE
       WRITE      (Round(QT3,3)),,FCLOSE
       WRITE      (Round(SR4/1000,3)),,FCLOSE
       WRITE      (Round(QT4,3)),,FCLOSE
       WRITE      (Round(QT$NETW,3)),,FCLOSE
       WRITE	  (Round(QA$NETW,3)),,FCLOSE
       WRITE	  (Round(QM$NETW,3)),,FCLOSE
FCLOSE CLOSE	  ERR
       TEST E	  P$ERR,0,ERROR
TERM1  TERMINATE  1
ERROR  TERMINATE  1
       START      6,NP
       EXIT	  -1
PROCEDURE Round(Number,Precision) BEGIN
       TEMPORARY StrNum,Point,RoundNum,NumDig;
       IF (Number=0) THEN RETURN "0";
       StrNum = String(Number);
       Point = Find(".",StrNum);
       IF (Point > 0) THEN BEGIN
	RoundNum = Abs(Number)+0.5#10^(-Precision);
	IF (Number < 0) THEN RoundNum = -RoundNum;
          IF (Precision=0) THEN NumDig = Point-1;
          ELSE NumDig = Point+Precision;
	StrNum = Left(String(RoundNum),NumDig);
       END;
       RETURN StrNum;
END;


